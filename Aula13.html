================================================================
Aula 14:
	Incorporando animações, sons, pausa e vidas extras ao jogo
================================================================

    Uma boa notícia: nesta aula, nosso jogo de nave será concluído! 
    Já temos um protótipo totalmente funcional, mas ainda hámuito o 
que sermelhorado para dar-lhe um aspecto profissional. 
    
    Serão feitas as seguintes melhorias:

    • Organização do código: nosso jogo está crescendo e, por isso, a
    página inicial vai começar a ficar um pouco longa e desorganizada.
    Faremos algumas refatorações para acomodar mais facilmente as mudanças
    que estão por vir.

    • Animação cronometrada: para a animação correr a velocidades constantes,
    e não no ritmo da CPU (do jeito que está, a velocidade da animação
    poderá oscilar muito).

    • Uso de spritesheets: nós aprendemos como usá-las no capítulo 4,mas
    não aplicamos ainda em nosso jogo! Com elas, criaremos explosões
    e daremos animação à nave, deixando nosso jogo muito mais interessante.
    
    • Pausa: como seria a experiência de jogar um jogo sem poder pausá-lo?
    Péssima, não é mesmo?

    • Som e música de fundo: você não estava sentindo a falta disto, não?

    • Telas de loading e Game Over: um jogo utiliza muitas imagens.
    Quando você hospedá-lo na internet, não vai querer que o usuário veja
    uma tela parada enquanto as imagens carregam, não é verdade? Um
    aviso “Carregando...” e uma barrinha aumentando na tela farão com
    que o internauta não desista do seu jogo; ao contrário, aumentará sua
    expectativa! E uma tela que indica quando o jogo acabou, cairá muito
    bem.

    • Vidas extras: por que o jogo tem que acabar na primeira colisão da
    nave? Vamos dar mais chances ao jogador!

    • Pontuação (score): esta simples regra de negócio será bem fácil de
    implementar.

    Primeiro, vamos organizar todo o nosso trabalho. Será uma excelente
oportunidade de revisão. Mãos à obra!

==============================
Organizando o código
==============================

    No jogo anterior, o código da página HTML de nosso jogo ficou um
tanto extenso, pois juntamos quase tudo o que aprendemos em um único arquivo
funcional. Considero esta uma boa hora para refatorar esse código (e
praticar um pouco também), deixando-o um pouco mais organizado e fácil
para acrescentar as melhorias que estão por vir. 
    
    Crie uma nova página HTML. Os arquivos de script devem ser copiados
de suas versões mais atualizadas.

<!-- arquivo: jogo-definitivo.html -->
<!DOCTYPE html>
<html>
<head>
<title>Jogo de Nave</title>
    <script src="animacao.js"></script>
    <script src="teclado.js"></script>
    <script src="colisor.js"></script>
    <script src="fundo.js"></script>
    <script src="nave.js"></script>
    <script src="ovni.js"></script>
    <script src="tiro.js"></script>
</head>
<body>
    <canvas id="canvas_animacao" width="500" height="500">
    </canvas>
    <script>
        // Vamos organizar um pouco este aplicativo!
    </script>
</body>
</html>


    Vamos continuar executando as tarefas nesta ordem: carregar as imagens,
iniciar os objetos, iniciar a animação. Que tal criar funções separadas? No
JavaScript, faça:

// Canvas e Context
var canvas = document.getElementById('canvas_animacao');
var context = canvas.getContext('2d');

// Variáveis principais
var imagens, animacao, teclado, colisor, nave, criadorInimigos;
var totalImagens = 0, carregadas = 0;

// Começa carregando as imagens
carregarImagens();

    Na função carregarImagens, facilita muito carregar um objeto ou array
com os nomes das imagens e fazer um loop nele. Optei por usar um objeto,
pois assim posso associar cada imagem a seu nome (em vez de usar um
número sem significado). Após carregar cada imagem, o nome é substituído
pelo objeto da imagem:
function carregarImagens() {
    // Objeto contendo os nomes das imagens
    imagens = {
        espaco: 'fundo-espaco.png',
        estrelas: 'fundo-estrelas.png',
        nuvens: 'fundo-nuvens.png',
        nave: 'nave.png',
        ovni: 'ovni.png'
    };

    // Carregar todas
    for (var i in imagens) {
        var img = new Image();
        img.src = 'img/' + imagens[i];
        img.onload = carregando;
        totalImagens++;
        // Substituir o nome pela imagem
        imagens[i] = img;
    }
}

    Temos então que criar a já conhecida função carregando, que vai monitorar
o carregamento das imagens e iniciar a criação dos objetos quando todas
estiverem prontas:

function carregando() {
    carregadas++;
    if (carregadas == totalImagens) iniciarObjetos();
}

    A função iniciarObjetos iniciará os principais objetos do jogo, da
forma como você já está acostumado a fazer:

function iniciarObjetos() {
    // Objetos principais
    animacao = new Animacao(context);
    teclado = new Teclado(document);
    colisor = new Colisor();
    espaco = new Fundo(context, imagens.espaco);
    estrelas = new Fundo(context, imagens.estrelas);
    nuvens = new Fundo(context, imagens.nuvens);
    nave = new Nave(context, teclado, imagens.nave);

    // Ligações entre objetos
    animacao.novoSprite(espaco);
    animacao.novoSprite(estrelas);
    animacao.novoSprite(nuvens);
    animacao.novoSprite(nave);
    colisor.novoSprite(nave);
    animacao.novoProcessamento(colisor);
    configuracoesIniciais();
}

    Foi chamada a função configuracoesIniciais, que configura as
velocidades dos fundos, posiciona a nave, configura o disparo pela tecla
Espaço e inicia a animação:

function configuracoesIniciais() {
    // Fundos
    espaco.velocidade = 3;
    estrelas.velocidade = 5;
    nuvens.velocidade = 10;

    // Nave
    nave.x = canvas.width / 2 - imagens.nave.width / 2;
    nave.y = canvas.height - imagens.nave.height;
    nave.velocidade = 5;

    // Tiro
    teclado.disparou(ESPACO, function() {
        nave.atirar();
    });
    
    animacao.ligar();
}

    Faça o teste: neste ponto você já deve ter a nave controlável e atirando, e o
fundo rolando. Vamos agora configurar a criação dos inimigos como um processamento
da animação. Ao final da função configuracoesIniciais,
acrescente a chamada a criacaoInimigos:

function configuracoesIniciais() {
    // ...
    criacaoInimigos();
}
    
    E vamos criar essa função. Ela cria um objeto sem construtor, com o
método processar, e o insere como um processamento geral na animação:

function criacaoInimigos() {
    criadorInimigos = {
        processar: function() {

        }
    };

    animacao.novoProcessamento(criadorInimigos);
}

    No método processar desse objeto, criaremos um inimigo a cada segundo.
Mas, para isso, necessitamos saber o instante em que o último inimigo
foi gerado. Este instante é guardado no atributo ultimoOvni e atualizado
quando o tempo decorrido ultrapassar 1000 milissegundos:

function criacaoInimigos() {
    var criador = {
        ultimoOvni: new Date().getTime(),
        processar: function() {
            var agora = new Date().getTime();
            var decorrido = agora - this.ultimoOvni;
            if (decorrido > 1000) {
                novoOvni();
                this.ultimoOvni = agora;
            }
        }
    };

    animacao.novoProcessamento(criador);
}

    Se passar um segundo desde a geração do último inimigo, é chamada a
função novoOvni, que é muito semelhante à do capítulo anterior. Ela gera
inimigos em posições e com velocidades aleatórias. Se não lembra como fazer
isso, consulte a aula anterior.

function novoOvni() {
    var imgOvni = imagens.ovni;
    var ovni = new Ovni(context, imgOvni);
    
    // Mínimo: 5; máximo: 20
    ovni.velocidade =
    Math.floor( 5 + Math.random() * (20 - 5 + 1) );
    
    // Mínimo: 0;
    // máximo: largura do canvas - largura do ovni
    ovni.x =
    Math.floor(Math.random() *
    (canvas.width - imgOvni.width + 1) );
    
    // Descontar a altura
    ovni.y = -imgOvni.height;
    animacao.novoSprite(ovni);
    colisor.novoSprite(ovni);
}

    Agora estamos muito mais organizados, com cada etapa da inicialização
do jogo em uma função específica. Estamos prontos para implementar as
novidades.


==============================
Animação cronometrada
==============================

    Para dar um aspecto mais profissional a nosso jogo, devemos cronometrar
as animações. Você pode ter notado que, às vezes, a velocidade oscila. Isto é
comumem browsers e jogos que rodam em sistemas operacionais multitarefa:
a CPU pode estar ocupada enquanto o jogo espera o momento de processar
o próximo ciclo.

    Para resolver isso, precisamos primeiro saber o tempo decorrido entre
um ciclo e outro. No construtor da classe Animacao, crie os atributos
ultimoCiclo (para guardar o instante do ciclo anterior, lido do relógio) e
decorrido (para guardar o tempo decorrido entre o ciclo anterior e o atual):

function Animacao(context) {
    // ...
    this.ultimoCiclo = 0;
    this.decorrido = 0;
}

    Para fazer os cálculos, obtemos o instante atual do relógio do computador
(dado por Date.getTime() em milissegundos) e calculamos a diferença
entre esse instante e o instante do ciclo anterior. Faremos isso no método
proximoFrame, logo antes de processar os sprites:

proximoFrame: function() {
    // Posso continuar?
    if ( ! this.ligado ) return;
    var agora = new Date().getTime();
    if (this.ultimoCiclo == 0) this.ultimoCiclo = agora;
    this.decorrido = agora - this.ultimoCiclo;

    //...
}

    No fim do método proximoFrame, atualize o atributo ultimoCiclo,
imediatamente antes de chamar o próximo ciclo:

proximoFrame: function() {
    // ...
    // Atualizar o instante do último ciclo
    this.ultimoCiclo = agora;
    // Chamamos o próximo ciclo
    var animacao = this;
    requestAnimationFrame(function() {
        animacao.proximoFrame();
    });
},

    Agora os sprites sabemquanto tempo levou entreumciclo e outro! Vamos
fazer o Fundo mover-se a uma velocidade constante. Para isso, modifique o
método atualizar:

atualizar: function() {
    // Atualizar a posição de emenda
    this.posicaoEmenda += this.velocidade * this.animacao.decorrido / 1000;
    // ...
},

=========================================================================
NOTA: Fórmula para animação cronometrada

    O incremento da posição do sprite, em pixels, é dado pela fórmula:

                velocidade * tempoDecorrido / 1000

Sendo:
    • velocidade em pixels por segundo;
    • tempoDecorrido em segundos (como o tempo dado por Date.getTime() 
    é em milissegundos, dividimos esse valor por 1000).
=========================================================================

    Note que agora o fundo move-se em velocidade constante, porém
bem devagar, pois passamos a trabalhar com pixels por segundo.
Podemos ajustar novas velocidades com valores maiores na função
configuracoesIniciais da página HTML. Você pode fazer vários testes
e atribuir os valores que desejar, dependendo da sensação de velocidade
que quer passar. Como as nuvens estão mais próximas, demos a elas a maior
velocidade, mas nada impede que coloquemos as estrelas em primeiro plano,
por exemplo:

function configuracoesIniciais() {
    // Fundos
    espaco.velocidade = 60;
    estrelas.velocidade = 150;
    nuvens.velocidade = 500;
    // ...
}

    Vamos cronometrar também o movimento da Nave. Aplique a fórmula
em seu método atualizar:

atualizar: function() {
    var incremento = this.velocidade * this.animacao.decorrido / 1000;

    // Use a variável incremento em todas as mudanças de x e y
    if (this.teclado.pressionada(SETA_ESQUERDA) && this.x > 0)
        this.x -= incremento;
    
    // ...
}

    Na página HTML, dei a ela a velocidade de 200 pixels por segundo:

// Nave
nave.x = canvas.width / 2 - imagens.nave.width / 2;
nave.y = canvas.height - imagens.nave.height;
nave.velocidade = 200;


=========================================================================
Exercício: faça você mesmo o ajuste para o Ovni e o Tiro! Dê-lhes as
velocidades que desejar. A do Tiro é configurada no construtor, e as dos
Ovnis, no método novoOvni da página.
=========================================================================

===================================
Animando a nave com spritesheets
===================================

    Vamos agora melhorar o aspecto de nossa nave. Convenhamos,
ela está muito parada... nem o fogo em sua cauda se mexe! Para
isso, vamos utilizar os sprites da Figura01.

    Na aula que falamos sobre animação, definimos que as linhas da 
spritesheet representam diferentes estados do sprite. Aqui temos a 
nave parada, movendo-se para a esquerda e movendo-se para a direita. 
Em uma linha, a animação ocorre avançando as colunas. Em cada uma 
destas linhas, há duas colunas que animam o fogo na cauda.

===========================
Iniciando o teste
===========================
    Para começar a programar com spritesheets, primeiro acrescente a 
referência ao arquivo spritesheet.js, que criamos em uma das aulas 
anteriores:

<script src="spritesheet.js"></script>

    Na função carregarImagens, mude a imagem da nave para o arquivo
nave-spritesheet.png:

imagens = {
    // ...
    nave: 'nave-spritesheet.png',
    // ...
};

    Agora não podemos mais usar as dimensões da imagem para posicionar
a nave. Em configuracoesIniciais, vamos passar valores absolutos referentes
a cada quadro (considerando que cada nave tem 36x48 pixels):

function configuracoesIniciais() {
    // ...
    // Nave
    nave.x = canvas.width / 2 - 18;     // 36 / 2
    nave.y = canvas.height - 48;
    nave.velocidade = 5;
    // ...
}

    No construtor da classe Nave, vamos iniciar o objeto que controla a
spritesheet. Usaremos inicialmente a linha zero, que representa a nave parada.
O intervalo entre um quadro e outro pode ser ajustado aos poucos conforme
o seu gosto:

function Nave(context, teclado, imagem) {
    // ...
    this.spritesheet = new Spritesheet(context, imagem, 3, 2);
    this.spritesheet.linha = 0;
    this.spritesheet.intervalo = 100;
}

    Altere agora o método desenhar para usar a spritesheet. Para definir
qual a linha a ser animada, lemos o estado das setas do teclado:

desenhar: function() {
    if (this.teclado.pressionada(SETA_ESQUERDA))
        this.spritesheet.linha = 1;
    else if (this.teclado.pressionada(SETA_DIREITA))
        this.spritesheet.linha = 2;
    else
        this.spritesheet.linha = 0;

    this.spritesheet.desenhar(this.x, this.y);
    this.spritesheet.proximoQuadro();
},

    Também precisamos alterar o método atualizar, pois ele também
está usando as dimensões da imagem para não deixá-la passar da borda
do Canvas. Nós substituímos as referências a this.imagem.width e
this.imagem.height pelos valores absolutos 36 e 48, respectivamente:

atualizar: function() {
    // ...
    if (this.teclado.pressionada(SETA_DIREITA) && this.x < this.context.canvas.width - 36)
        this.x += this.velocidade;

    // ...

    if (this.teclado.pressionada(SETA_ABAIXO) && this.y < this.context.canvas.height - 48)
        this.y += this.velocidade;
},


    Por último, perceba que o tiro sai um pouco deslocado, pois sua posição
é calculada pelo tamanho da imagem antiga. Vamos ajustar para um valor
absoluto, no construtor da classe Tiro. Também aproveitei omomento para
mudar a cor e deixá-lo um pouco menor:

function Tiro(context, nave) {
    this.context = context;
    this.nave = nave;

    // Posicionar o tiro no bico da nave
    this.largura = 3;
    this.altura = 10;
    this.x = nave.x + 18;           // 36 / 2
    this.y = nave.y - this.altura;
    this.velocidade = 10;

    this.cor = 'yellow';
}

    Experimente jogar e perceba que o movimento da nave ganhou mais 
dinamismo!

=========================
Criando explosões
=========================

    Vamos aproveitar o embalo das spritesheets e criar explosões. 
Usaremos o arquivo explosao.png, que contém a spritesheet na Figura02.

    Também será preciso acrescentar uma referência ao script
explosao.js, a ser criado logo mais:

<script src="explosao.js"></script>

Na função carregarImagens, acrescente a imagem da explosão:
imagens = {
    // ...
    ovni: 'ovni.png', // uma vírgula aqui
    explosao: 'explosao.png'
};
    
    No método colidiuCom da classe Ovni, onde este é destruído pelo
Tiro, vamos criar uma explosão:

colidiuCom: function(outro) {
    // Se colidiu com um Tiro, os dois desaparecem
    if (outro instanceof Tiro) {
        // ...
        var explosao = new Explosao(this.context, this.imgExplosao, this.x, this.y);
        
        this.animacao.novoSprite(explosao);
    }
}

    Os objetos que explodem precisam receber a imagem da explosão, 
para poder criar os sprites. Mude o construtor do Ovni:

function Ovni(context, imagem, imgExplosao) {
    // ...
    this.imgExplosao = imgExplosao;
}

    E passe a imagem na função novoOvni da página HTML:

var ovni = new Ovni(context, imgOvni, imagens.explosao);

    Agora, crie a classe Explosao no arquivo explosao.js:

function Explosao(context, imagem, x, y) {
    this.context = context;
    this.imagem = imagem;
    this.spritesheet = new Spritesheet(context, imagem, 1, 5);
    this.spritesheet.intervalo = 75;
    this.x = x;
    this.y = y;
}

Explosao.prototype = {
    atualizar: function() {
    
    },
    
    desenhar: function() {

    }
}

    No método desenhar, nós desenhamos o quadro atual e animamos a
spritesheet:

desenhar: function() {
    this.spritesheet.desenhar(this.x, this.y);
    this.spritesheet.proximoQuadro();
}

    Mas assim a explosão ficará piscando na tela eternamente! O que queremos
é que, quando todos os quadros forem exibidos, a explosão termine.

    Mas como saber se a spritesheet chegou ao último quadro? Vamos criar
nela uma funcionalidade com a qual ela própria avisa isto. No construtor
da Explosao, crie um callback que recebe esse aviso:

function Explosao(context, imagem, x, y) {
    // ...
    var explosao = this;
    this.spritesheet.fimDoCiclo = function() {
        explosao.animacao.excluirSprite(explosao);
    }
}

    Agora crie o atributo fimDoCiclo no construtor da Spritesheet:

function Spritesheet(context, imagem, linhas, colunas) {
    // ...
    this.fimDoCiclo = null;
}

    E modifique o método proximoQuadro() para chamar esse callback
quando voltar ao quadro zero:

proximoQuadro: function() {
    // ...
    if (this.coluna < this.numColunas - 1) {
        this.coluna++;
    }

    else {
        this.coluna = 0;
        // Avisar que acabou um ciclo!
        if (this.fimDoCiclo) this.fimDoCiclo();
    }
    // ...
},

    Experimente jogar! O Ovni já explode ao ser atingido pelo tiro. 
Agora vamos explodir tanto a Nave quanto o Ovni quando eles colidirem. 
No método colidiuCom da Nave, vamos criar duas explosões:

colidiuCom: function(outro) {
    // Se colidiu com um Ovni...
        if (outro instanceof Ovni) {
        this.animacao.excluirSprite(this);
        this.animacao.excluirSprite(outro);
        this.colisor.excluirSprite(this);
        this.colisor.excluirSprite(outro);

        var exp1 = new Explosao(this.context, this.imgExplosao, this.x, this.y);

        var exp2 = new Explosao(this.context, this.imgExplosao, outro.x, outro.y);

        this.animacao.novoSprite(exp1);
        this.animacao.novoSprite(exp2);
        // Por enquanto tire o término da animação
    }
}

    Claro, a Nave também precisará receber a imagem da explosão no construtor:

function Nave(context, teclado, imagem, imgExplosao) {
    // ...
    this.imgExplosao = imgExplosao;
}

    Portanto, passe-a ao criar a nave (método iniciarObjetos da página
HTML):

nave = new Nave(context, teclado, imagens.nave, imagens.explosao);

    A Nave e o Ovni já explodem juntos. Gostaríamos de parar a animação
e dar a mensagem “GAME OVER” somente quando essas explosões finalizarem. 
Portanto, o sprite Explosao também poderia receber um callback.
Complete o colidiuCom da Nave para passar esse callback:

colidiuCom: function(outro) {
    // Se colidiu com um Ovni...
    if (outro instanceof Ovni) {
        // ...
        exp1.fimDaExplosao = function() {
            animacao.desligar();
            alert('GAME OVER');
        }
    }
}

    E modifique o construtor da Explosao para chamar esse callback ao fim
do ciclo da spritesheet:

function Explosao(context, imagem, x, y) {
    // ...
    var explosao = this;
    this.fimDaExplosao = null;
    this.spritesheet.fimDoCiclo = function() {
        explosao.animacao.excluirSprite(explosao);
        if (explosao.fimDaExplosao) 
            explosao.fimDaExplosao();
    }
}

    Não é legal? A Spritesheet informa à Explosao quando completou
a animação dos quadros, e a Explosao se retira da animação e notifica a
quem interessar (Figura03).

    Vamos brincar um pouco, afinal merecemos.


============================
Pausando o jogo
============================

    Nós já temos pausa implementada em nosso game engine: osmétodos ligar
e desligar da classe Animacao. No entanto, é preciso tratar alguns acontecimentos
que estão ocorrendo na animação, ao se pausar o jogo.

    Vamos definir que o jogador pausará o jogo através da tecla Enter, cujo
código é 13 (se preferir usar outra tecla, fique à vontade).

    No início do arquivo teclado.js, acrescenteuma variável para guardar
o código do Enter:

// Códigos de teclas - aqui vão todos os que forem necessários
var SETA_ESQUERDA = 37;
var SETA_ACIMA = 38;
var SETA_DIREITA = 39;
var SETA_ABAIXO = 40;

var ESPACO = 32;
var ENTER = 13;

    Agora, nométodo configuracoesIniciais, configure a ação da tecla
Enter:

// Pausa
teclado.disparou(ENTER, pausarJogo);

    E crie a função pausarJogo, que é quem fará o trabalho:

function pausarJogo() {
    if (animacao.ligado)
        animacao.desligar();
    else
        animacao.ligar();
}

    Faça o teste: neste ponto o jogo já deve pausar e despausar. No entanto,
você poderá notar alguns bugs. Primeiro, pause enquanto um disco voador
está na tela, e em seguida despause: ele some! Isso ocorre porque sua animação
está cronometrada, e o tempo da pausa está sendo contado para calcular
seumovimento. Quando a animação reinicia, o disco já deve estar longe,
e assim o jogo o posiciona.

    Para resolver isso, na classe Animacao, no método ligar, reinicie o
atributo ultimoCiclo para zero. Isto fará a contagem de tempo ser reiniciada:

ligar: function() {
    this.ultimoCiclo = 0;
    this.ligado = true;
    this.proximoFrame();
},

    Um outro problema é: funções de disparo (no caso, o tiro) continuam
sendo possíveis! Isto não ocorre com a movimentação pelas setas, pois são
lidas no método atualizar da Nave, dentro do loop de animação (que
estaria pausado).

    Modifiquemos a função para desativar ou reativar a tecla Espaço (tiro)
conforme pausamos e despausamos o jogo:

function pausarJogo() {
    if (animacao.ligado) {
        animacao.desligar();
        ativarTiro(false);
    }
    else {
        animacao.ligar();
        ativarTiro(true);
    }
}

    A função ativarTiro vai modificar os eventos do teclado, configurando
a tecla Espaço:

function ativarTiro(ativar) {
    if (ativar) {
        teclado.disparou(ESPACO, function() {
            nave.atirar();
        });
    }
    
    else
        teclado.disparou(ESPACO, null);
}

    Para não ficarmos com código repetido, em configuracoesIniciais, remova 
as linhas:

// Remova estas linhas
// Tiro
teclado.disparou(ESPACO, function() {
    nave.atirar();
});

E coloque esta no lugar:
// Tiro
ativarTiro(true);

    Também ocorre que um inimigo é gerado imediatamente após a des-pausa,
pois estamos gerando um inimigo por segundo e a pausa faz esse tempo se
exceder. Antes de ligar a animação, reinicie omomento da geração do último
inimigo para o instante atual, para evitar que isso ocorra:
function pausarJogo() {
    // ...
    
    else {
        criadorInimigos.ultimoOvni = new Date().getTime();
        animacao.ligar();
        ativarTiro(true);
    }
}

    Quantos detalhes uma simples pausa nos obriga a tratar! Para ficar mais
interessante, vamos exibir o texto “Pausado” na tela:

function pausarJogo() {
    if (animacao.ligado) {
        animacao.desligar();
        ativarTiro(false);

        // Escrever "Pausado"
        context.save();
        context.fillStyle = 'white';
        context.strokeStyle = 'black';
        context.font = '50px sans-serif';
        context.fillText("Pausado", 160, 200);
        context.strokeText("Pausado", 160, 200);
        context.restore();
    }
    else {
        criadorInimigos.ultimoOvni = new Date().getTime();
        animacao.ligar();
        ativarTiro(true);
    }
}
    
    Use sua imaginação! Coloque qualquer imagem, texto, ou combinação
dos dois. Pode até instanciar outra Animacao, colocar alguns sprites 
específicos e exibir alguns movimentos durante a pausa.


==========================
Sons e música de fundo
==========================

    Esta parte é muito fácil de implementar. O HTML5, além do Canvas, possui
uma API de áudiomuito simples. No pacote de arquivos disponibilizada para 
vocês, há uma subpasta com o nome snd contendo alguns arquivos de som, em 
formato MP3.

=============================================================================
NOTA: Bancos de sons grátis e direitos autorais

    Jamais use sons de terceiros sem a devida autorização! Criadores
de jogos independentes, sem meios ou conhecimentos para gerar seus
próprios sons, podem contar com inúmeros bancos de sons gratuitos 
espalhados pela internet.
    
    Os sons para o nosso protótipo foram obtidos em http://freesound.org.
==============================================================================

    Primeiro, vamos produzir o som dos tiros. Abra o arquivo tiro.js e
coloque as instruções para carregar o som logo no início do arquivo. 
Instanciamos um objeto Audio (presente na API do HTML5), setamos seu atributo
src para o arquivo tiro.mp3 (presente no pacote de download) e ajustamos
o volume como um valor entre 0 e 1. Por último, chamamos o método load
para iniciar o carregamento do arquivo, evitando que seja carregado somente
no momento da reprodução:

var SOM_TIRO = new Audio();
SOM_TIRO.src = 'snd/tiro.mp3';
SOM_TIRO.volume = 0.2;
SOM_TIRO.load();

    Depois, vamos reproduzir esse som cada vez que um tiro é criado. No
construtor, rebobinamos o som ajustando o atributo currentTime para zero. 
Esse atributo indica o instante atual de reprodução, dado em segundos.
Em seguida, basta chamar o método play:

function Tiro(context, nave) {
    // ...
    SOM_TIRO.currentTime = 0.0;
    SOM_TIRO.play();
}

    Os tiros já fazem barulho! Vamos fazer o mesmo procedimento para as
explosões. No início do arquivo explosao.js, coloque as instruções:

var SOM_EXPLOSAO = new Audio();
SOM_EXPLOSAO.src = 'snd/explosao.mp3';
SOM_EXPLOSAO.volume = 0.4;
SOM_EXPLOSAO.load();

    E no construtor,mande rebobinar e reproduzir, damesma forma que com
o Tiro:

function Explosao(context, imagem, x, y) {
    // ...
    SOM_EXPLOSAO.currentTime = 0.0;
    SOM_EXPLOSAO.play();
}

Vamos também colocar uma música de fundo para dar mais emoção ao
jogo. No início da página HTML, acrescente a variável musicaAcao:

// Variáveis principais
var imagens, animacao, teclado, colisor, nave, criadorInimigos;
var totalImagens = 0, carregadas = 0;
var musicaAcao;

    Em seguida, logo após a chamada para carregarImagens, coloque
também uma chamada para carregarMusicas:

// Começa carregando as imagens e músicas
carregarImagens();
carregarMusicas();

    E crie a função carregarMusicas. Aqui, setamos o atributo loop para
true, fazendo com que a música repita incessantemente durante a ação do
jogo.

function carregarMusicas() {
    musicaAcao = new Audio();
    musicaAcao.src = 'snd/musica-acao.mp3';
    musicaAcao.load();
    musicaAcao.volume = 0.8;
    musicaAcao.loop = true;
    musicaAcao.play();
}

    Viu como é bem fácil? Divirta-se mais um pouco!

==================================================================
Dica: você pode parar a música no momento da pausa usando o método
pause.
==================================================================


===================================
Tela de loading
===================================

    Vamos modificar a função carregando da página HTML para incrementar
uma barra conforme as imagens vão sendo carregadas (Figura05). Primeiro, 
como vamos desenhar, guarde a configuração atual do contexto (método save) 
e crie um fundo. Aqui, fiz um fundo simples, coma imagem do espaço. Se 
tiver vontade faça um desenho mais elaborado. Sinta-se livre!

function carregando() {
    context.save();
    
    // Fundo
    context.drawImage(imagens.espaco, 0, 0, canvas.width,
    canvas.height);
    
    // continua ...
}

    Em seguida, vamos criar o texto “Carregando":

function carregando() {
    // ...

    // Texto "Carregando"
    context.fillStyle = 'white';
    context.strokeStyle = 'black';
    context.font = '50px sans-serif';
    context.fillText("Carregando...", 100, 200);
    context.strokeText("Carregando...", 100, 200);
    // continua ...
}

    O próximo passo é desenhar a barra. Neste ponto, precisamos incrementar
a variável carregadas, para poder calcular a largura atual da barra:
function carregando() {
    // ...

    // Barra de loading
    carregadas++;
    var tamanhoTotal = 300;
    var tamanho = carregadas / totalImagens * tamanhoTotal;
    context.fillStyle = 'yellow';
    context.fillRect(100, 250, tamanho, 50);

    // continua ...
}

    Por último, restauramos as configurações anteriores do contexto (método
restore) e, em vez de iniciar o jogo imediatamente, vamosmostrar um link
“Jogar”, a ser criado logo adiante, para o jogador clicar quando estiver pronto:
function carregando() {
    // ...
    context.restore();

    if (carregadas == totalImagens) {
        iniciarObjetos();
        mostrarLinkJogar();
    }
}

    Como o jogo não vai iniciar automaticamente, tire o comando que inicia
a animação da função configuracoesIniciais:

// Remova esta linha
animacao.ligar();
    
    E também a chamada ao método play da função carregarMusicas:

// Remova esta linha
musicaAcao.play();

    
    Crie então um link para iniciar o jogo. Logo após a tag <canvas>, insira
esse link, com uma chamada para a função iniciarJogo:

<a id="link_jogar" href="javascript: iniciarJogo()">Jogar</a>

    Vamos configurar sua aparência e posição via CSS. Você pode configurar
esse botão da forma que quiser, e não é o foco deste livro ficar detalhando
formatações em CSS. Caso não tenha muita prática, aí está uma formatação
sugerida. No pacote de downloads, existe a imagem botao-jogar.png,
que usei como fundo.

    Na seção <head> do documento (pode ser após os scripts), crie uma tag
<style>. O mais importante é que o botão inicie oculto e tenha posicionamento
absoluto, para podermos colocá-lo por cima do Canvas:

<style>
#link_jogar {
    /* Inicia oculto */
    display: none;

    /* Cores e fundo */
    color: yellow;
    background: url(img/botao-jogar.png);
    
    /* Fonte */
    font-size: 20px;
    font-family: sans-serif;
    
    /* Sem sublinhado e com sombra */
    text-decoration: none;
    text-shadow: 2px 2px 5px black;
    
    /* Posicionamento */
    position: absolute;
    left: 220px;
    top: 330px;
    
    /* A imagem do botão é 72x72, descontamos os paddings */
    width: 52px;
    height: 26px;
    padding: 23px 10px;
}
</style>

    E crie a função mostrarLinkJogar, que mandará mostrar esse link,
modificando seu atributo CSS display para o valor block.

function mostrarLinkJogar() {
    document.getElementById('link_jogar').style.display = 'block';
}

    A função iniciarJogo, chamada pelo link, irá esconder o link “Jogar”,
iniciar a música e ligar a animação:

function iniciarJogo() {
    document.getElementById('link_jogar').style.display = 'none';
    musicaAcao.play();
    animacao.ligar();
}

    Faça o teste! Enquanto você estiver testando o jogo em seu computador,
a tela carregará bem rapidamente. No entanto, ela fará (muita) diferença
quando hospedarmos nosso jogo na web.

    Ainda temos um problema: a tecla Enter dá início ao jogo sem fazer
sumir o botão Jogar! Isso ocorre porque ela está despausando o jogo em um
momento em que a animação não está rodando.

    Para corrigir isso, vamos tirar as seguintes linhas de
configuracoesIniciais:

// Remova estas linhas
// Tiro
ativarTiro(true);

// E estas também
// Pausa
    eclado.disparou(ENTER, pausarJogo);

Vamos ativá-las em iniciarJogo:

function iniciarJogo() {
    // Tiro
    ativarTiro(true);
    
    // Pausa
    teclado.disparou(ENTER, pausarJogo);
    
    // ...
}


============================
Vidas extras
============================
    Programar vidas extras não é tão complicado, tudo é questão de mexer nos
algoritmos da nave. Para facilitar, vamos criar um atributo de callback onde
a Nave nos informa quando acabaramas vidas. No construtor, crie esse callback
e o atributo vidasExtras:

function Nave(context, teclado, imagem, imgExplosao) {
    // ...
    this.acabaramVidas = null;
    this.vidasExtras = 3;
}

    No método colidiuCom, onde detectamos sua colisão mortal, retire as
linhas que mandam finalizar o jogo:

// Retire estas linhas:
exp1.fimDaExplosao = function() {
    animacao.desligar();
    alert('GAME OVER');
}

    E substitua-as pelo código a seguir. Nós vamos decrementar o atributo
vidasExtras, e verificar se as vidas acabaram (e notificar, se for o caso).
Caso o jogo continue, nós recolocamos a nave na animação e no colisor e a
reposicionamos:

var nave = this;
exp1.fimDaExplosao = function() {
    nave.vidasExtras--;
    if (nave.vidasExtras < 0) {
        if (nave.acabaramVidas) 
            nave.acabaramVidas();
    }

    else {
        // Recolocar a nave no engine
        nave.colisor.novoSprite(nave);
        nave.animacao.novoSprite(nave);
        nave.posicionar();
    }
}

    O posicionamento da nave é exatamente o que já estamos fazendo na
função configuracoesIniciais da página HTML. Retire as linhas:

// Nave
// Retire as duas linhas abaixo
nave.x = canvas.width / 2 - 18;         // 36 / 2
nave.y = canvas.height - 48;

    E coloque no lugar uma chamada ao método posicionar:

// Nave
nave.posicionar();
nave.velocidade = 200;

    Vamos criar o método na Nave, fazendo essa mesma tarefa:

posicionar: function() {
    var canvas = this.context.canvas;
    this.x = canvas.width / 2 - 18;         // 36 / 2
    this.y = canvas.height - 48;
}

    Por fim, em configuracoesIniciais, insira as linhas que finalizam
o jogo, respondendo ao callback acabaramVidas da Nave:

function configuracoesIniciais() {
    // ...
    // Game Over
    nave.acabaramVidas = function() {
        animacao.desligar();
        alert('GAME OVER');
    }
}

========================================================================
Exercício: implemente, através da leitura do teclado, um cheat 
code que dê mais vidas ao jogador!
========================================================================

Um mostrador de vidas

    Legal, nossa nave já tem vidas extras! Vamos criar agora o arquivo
painel.js, para mostrar essas vidas extras. Seu esqueleto fica:

// arquivo: painel.js
function Painel(context, nave) {
    this.context = context;
    this.nave = nave;
}

Painel.prototype = {
    atualizar: function() {
    
    },

    desenhar: function() {

    }
}

    Claro, insira o script na seção <head>:

<script src="painel.js"></script>

    Na função iniciarObjetos, crie o painel e insira-o na animação.
Optei por deixar a nave por último, para que ela sempre fique acima do 
painel:

function iniciarObjetos() {
    // Objetos principais
    // ...
    painel = new Painel(context, nave);

    // Ligações entre objetos
    // ...
    animacao.novoSprite(painel);
    animacao.novoSprite(nave);

    // ...
}

    No construtor do Painel, vamos criar uma spritesheet a partir da imagem
da nave. Nós usaremos somente a primeira imagem, que corresponde
à nave parada:

function Painel(context, nave) {
    // ...
    this.spritesheet =
    new Spritesheet(context, nave.imagem, 3, 2);
    this.spritesheet.linha = 0;
    this.spritesheet.coluna = 0;
}

    Nométodo desenhar, obtemos o número de vidas extras e desenhamos
a imagem esse número de vezes:

desenhar: function() {
    var x = 20;
    var y = 20;
    for (var i = 1; i <= this.nave.vidasExtras; i++) {
        this.spritesheet.desenhar(x, y);
        x += 40;
    }
}

    Eu achei que os desenhos das vidas estão muito grandes. Vou usar aqui o
método scale do context para desenhá-los com metade do tamanho:

desenhar: function() {
    // Reduz o desenho pela metade
    this.context.scale(0.5, 0.5);

    var x = 20;
    var y = 20;
    for (var i = 1; i <= this.nave.vidasExtras; i++) {
        this.spritesheet.desenhar(x, y);
        x += 40;
    }

    // Torna a dobrar
    this.context.scale(2, 2);
}

    Você pode usar o tamanho que preferir, ou mesmo usar um arquivo de
imagem apenas para isso, em tamanho menor. Mas com o scale é bem
mais econômico, não acha?


=============================
Pontuação (score)
=============================
    Aproveitando que temos um painel mostrador de vidas, podemos criar 
nele um atributo pontuacao. Em sua função construtora, coloque a instrução:

this.pontuacao = 0;

    Em configuracoesIniciais, vamos criar um tratador geral de colisões
que verifica se é um Tiro e um Ovni que estão colidindo. Em caso
positivo, incrementamos essa pontuação no painel:

function configuracoesIniciais() {
    // ...
    // Pontuação
    colisor.aoColidir = function(o1, o2) {
        // Tiro com Ovni
        if ((o1 instanceof Tiro && o2 instanceof Ovni) || (o1 instanceof Ovni 
         && o2 instanceof Tiro))
            painel.pontuacao += 10;
            // Use o incremento que desejar
    }
}

    Agora, modifique o método desenhar do painel para escrever a pontuação
ao lado dos ícones das vidas:

desenhar: function() {
    // ...
    // Para facilitar um pouco...
    var ctx = this.context;
    // Pontuação
    ctx.save();
    ctx.fillStyle = 'white';
    ctx.font = '18px sans-serif';
    ctx.fillText(this.pontuacao, 100, 27);
    ctx.restore();
}

    Por último, não se esqueça de zerar o painel cada vez que o jogo inicia,
do contrário a pontuação fica lá para a próxima partida. Em iniciarJogo,
coloque o comando:

painel.pontuacao = 0;


=============================
Tela de Game Over
=============================

    Vamos finalizar nosso jogo criando uma tela de Game Over! Em
configuracoesIniciais, tire aquele alerta horrível e troque por uma
chamada à função gameOver (Figura06):

function configuracoesIniciais() {
    // ...
    // Game Over
    nave.acabaramVidas = function() {
        animacao.desligar();
        gameOver();
    }
}

    Nessa função, vamos desativar as teclas de disparo, parar a música e 
criar uma tela mais adequada. O link “Jogar” deve voltar a aparecer, e a 
nave deve ser recolocada no game engine (pois foi tirada no momento da 
colisão):

function gameOver() {
    // Tiro
    ativarTiro(false);

    // Pausa
    teclado.disparou(ENTER, null);

    // Parar a música e rebobinar
    musicaAcao.pause();
    musicaAcao.currentTime = 0.0;

    // Fundo
    context.drawImage(imagens.espaco, 0, 0, canvas.width, canvas.height);

    // Texto "Game Over"
    context.save();
    context.fillStyle = 'white';
    context.strokeStyle = 'black';
    context.font = '70px sans-serif';
    context.fillText("GAME OVER", 40, 200);
    context.strokeText("GAME OVER", 40, 200);
    context.restore();

    // Volta o link "Jogar"
    mostrarLinkJogar();

    // Restaurar as condições da nave
    nave.vidasExtras = 3;
    nave.posicionar();
    animacao.novoSprite(nave);
    colisor.novoSprite(nave);
}

    Você perceberá uma coisa: Ovnis que sobraram na animação, continuam
lá para o próximo jogo! Ao fim de gameOver, chame uma nova função,
removerInimigos:

function gameOver() {
    // ...
    removerInimigos();
}

    Nesta função, nós mandamos excluir todos os Ovnis da animação:

function removerInimigos() {
    for (var i in animacao.sprites) {
        if (animacao.sprites[i] instanceof Ovni)
            animacao.excluirSprite(animacao.sprites[i]);
    }
}

    Finalmente, reinicie o instante da geração de inimigos em
iniciarJogo, para que não surja um Ovni de repente quando o
jogo for reiniciado. Faça isto antes de ligar a animação:

function iniciarJogo() {
    criadorInimigos.ultimoOvni = new Date().getTime();
    // ...
}

    Pode soltar fogos de artifício! 
    
    Temos um jogo simples, embora completo em termos de animação, 
engine e algoritmos.


========================
Exercícios
========================
    Agora ficará por sua conta melhorar o jogo! Aqui estão algumas 
sugestões do que você pode fazer:

    • Criar novos tipos de inimigos;
    • Fases e cenários diferentes;
    • Tipos diferentes de naves e tiros;
    • Coleta de itens;